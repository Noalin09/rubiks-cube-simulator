<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 終極魔術方塊 - 修復增強版</title>
    <style>
        :root { --primary: #3498db; --bg: #1a1a1a; --text: #eee; }
        body { margin: 0; overflow: hidden; background-color: var(--bg); color: var(--text); font-family: sans-serif; }
        canvas { display: block; }

        /* UI Panel */
        #ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 15px; display: flex; flex-direction: column; justify-content: space-between; }
        .panel { pointer-events: auto; background: rgba(0,0,0,0.8); backdrop-filter: blur(8px); padding: 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.1); }
        
        .controls { width: 200px; display: flex; flex-direction: column; gap: 8px; }
        .stats { position: absolute; top: 15px; right: 15px; text-align: right; }
        .btn-group { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; }
        
        button { background: #333; color: white; border: 1px solid #555; padding: 6px; border-radius: 4px; cursor: pointer; font-size: 11px; }
        button:hover { background: var(--primary); border-color: var(--primary); }
        button.active { background: var(--primary); border-color: white; }
        h4 { margin: 5px 0; font-size: 13px; color: #aaa; text-transform: uppercase; }
        .timer { font-size: 22px; font-weight: bold; font-family: monospace; color: var(--primary); }
        .hint { font-size: 10px; color: #666; margin-top: 5px; }
    </style>
</head>
<body>

<div id="ui-overlay">
    <div class="controls panel">
        <h4>1. 階數選擇</h4>
        <div class="btn-group">
            <button data-cmd="order" data-val="2">2x2</button>
            <button data-cmd="order" data-val="3" class="active">3x3</button>
            <button data-cmd="order" data-val="4">4x4</button>
        </div>

        <h4>2. 工具</h4>
        <button data-cmd="scramble">打亂方塊 (Scramble)</button>
        <button data-cmd="undo">悔步 (Undo)</button>
        <button data-cmd="reset">重置 (Reset)</button>

        <h4>3. 系統</h4>
        <button data-cmd="wireframe">透視模式</button>
        <button data-cmd="camera">視角重置</button>
        <button data-cmd="theme">深/淺色切換</button>
        <div class="hint">鍵盤: U, D, L, R, F, B 轉動</div>
    </div>

    <div class="stats panel">
        <div class="timer" id="timer">00:00.0</div>
        <div id="move-count">步數: 0</div>
    </div>
</div>

<!-- 使用穩定版 CDN 並包含所有依賴 -->
<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.2/index.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import gsap from 'gsap';

    // --- 全域變數 ---
    let scene, camera, renderer, controls, cubeGroup;
    let currentOrder = 3;
    let isAnimating = false;
    let isWireframe = false;
    let moveHistory = [];
    let moveCounter = 0;
    let timerInterval, startTime, isTimerStarted = false;

    const COLORS = {
        top: 0xffd500, bottom: 0xffffff, front: 0xb7121f,
        back: 0xff5800, left: 0x0046ad, right: 0x009b48, inside: 0x111111
    };

    // --- 初始化 ---
    init();
    animate();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(6, 6, 10);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // 增強光照，確保方塊清晰
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.position.set(10, 20, 10);
        scene.add(sunLight);

        createCube(currentOrder);
        setupEventListeners();
    }

    // --- 核心功能：建立魔方 ---
    function createCube(order) {
        if (cubeGroup) scene.remove(cubeGroup);
        cubeGroup = new THREE.Group();
        
        const offset = (order - 1) / 2;
        const spacing = 1.0; 
        const geometry = new THREE.BoxGeometry(0.96, 0.96, 0.96);

        for (let x = 0; x < order; x++) {
            for (let y = 0; y < order; y++) {
                for (let z = 0; z < order; z++) {
                    const materials = [
                        new THREE.MeshStandardMaterial({ color: (x === order - 1) ? COLORS.right : COLORS.inside }),
                        new THREE.MeshStandardMaterial({ color: (x === 0) ? COLORS.left : COLORS.inside }),
                        new THREE.MeshStandardMaterial({ color: (y === order - 1) ? COLORS.top : COLORS.inside }),
                        new THREE.MeshStandardMaterial({ color: (y === 0) ? COLORS.bottom : COLORS.inside }),
                        new THREE.MeshStandardMaterial({ color: (z === order - 1) ? COLORS.front : COLORS.inside }),
                        new THREE.MeshStandardMaterial({ color: (z === 0) ? COLORS.back : COLORS.inside })
                    ];

                    const cubie = new THREE.Mesh(geometry, materials);
                    // 關鍵：精確計算位置
                    cubie.position.set(x - offset, y - offset, z - offset);
                    cubie.userData.originalPos = cubie.position.clone();
                    cubeGroup.add(cubie);
                }
            }
        }
        scene.add(cubeGroup);
    }

    // --- 旋轉邏輯（修復浮點數 bug） ---
    async function rotateLayer(axis, layerIndex, angle, isUndo = false) {
        if (isAnimating) return;
        isAnimating = true;

        if (!isTimerStarted && !isUndo) startTimer();

        const pivot = new THREE.Group();
        scene.add(pivot);

        const offset = (currentOrder - 1) / 2;
        const targetCoord = layerIndex - offset;

        // 選取符合該層座標的小方塊（加入小量誤差容許值 0.1）
        const targets = [];
        const children = [...cubeGroup.children];
        children.forEach(cubie => {
            if (Math.abs(cubie.position[axis] - targetCoord) < 0.1) {
                targets.push(cubie);
                pivot.attach(cubie);
            }
        });

        await gsap.to(pivot.rotation, {
            [axis]: angle,
            duration: 0.35,
            ease: "power2.inOut"
        });

        // 動畫結束，放回群組並「強制校正」座標
        targets.forEach(cubie => {
            cubeGroup.attach(cubie);
            cubie.position.x = Math.round(cubie.position.x * 2) / 2;
            cubie.position.y = Math.round(cubie.position.y * 2) / 2;
            cubie.position.z = Math.round(cubie.position.z * 2) / 2;
            // 同時校正旋轉，避免萬向鎖誤差累積
            cubie.rotation.set(
                Math.round(cubie.rotation.x / (Math.PI/2)) * (Math.PI/2),
                Math.round(cubie.rotation.y / (Math.PI/2)) * (Math.PI/2),
                Math.round(cubie.rotation.z / (Math.PI/2)) * (Math.PI/2)
            );
        });

        scene.remove(pivot);
        if (!isUndo) {
            moveHistory.push({ axis, layerIndex, angle });
            moveCounter++;
            updateUI();
        }
        isAnimating = false;
    }

    // --- UI 與 事件處理 ---
    function setupEventListeners() {
        // 按鈕監聽
        document.querySelectorAll('button[data-cmd]').forEach(btn => {
            btn.addEventListener('click', () => {
                const cmd = btn.dataset.cmd;
                const val = btn.dataset.val;

                if (cmd === 'order') {
                    document.querySelectorAll('button[data-cmd="order"]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentOrder = parseInt(val);
                    resetAll();
                } else if (cmd === 'scramble') {
                    scramble();
                } else if (cmd === 'undo') {
                    undo();
                } else if (cmd === 'reset') {
                    resetAll();
                } else if (cmd === 'wireframe') {
                    isWireframe = !isWireframe;
                    cubeGroup.children.forEach(c => c.material.forEach(m => m.wireframe = isWireframe));
                } else if (cmd === 'camera') {
                    gsap.to(camera.position, { x: 6, y: 6, z: 10, duration: 1, onUpdate: () => camera.lookAt(0,0,0) });
                } else if (cmd === 'theme') {
                    const isDark = scene.background.getHex() === 0x1a1a1a;
                    scene.background.set(isDark ? 0xdddddd : 0x1a1a1a);
                }
            });
        });

        // 鍵盤監聽
        window.addEventListener('keydown', (e) => {
            const k = e.key.toUpperCase();
            const lastIdx = currentOrder - 1;
            const moveMap = {
                'U': ['y', lastIdx, -Math.PI/2], 'D': ['y', 0, Math.PI/2],
                'L': ['x', 0, Math.PI/2], 'R': ['x', lastIdx, -Math.PI/2],
                'F': ['z', lastIdx, -Math.PI/2], 'B': ['z', 0, Math.PI/2]
            };
            if (moveMap[k]) rotateLayer(...moveMap[k]);
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    function resetAll() {
        moveHistory = [];
        moveCounter = 0;
        isTimerStarted = false;
        clearInterval(timerInterval);
        document.getElementById('timer').innerText = "00:00.0";
        updateUI();
        createCube(currentOrder);
    }

    async function scramble() {
        if (isAnimating) return;
        resetAll();
        const axes = ['x', 'y', 'z'];
        for (let i = 0; i < 12; i++) {
            const axis = axes[Math.floor(Math.random() * 3)];
            const layer = Math.floor(Math.random() * currentOrder);
            const angle = Math.random() > 0.5 ? Math.PI/2 : -Math.PI/2;
            await rotateLayer(axis, layer, angle);
        }
    }

    function undo() {
        if (moveHistory.length === 0 || isAnimating) return;
        const last = moveHistory.pop();
        rotateLayer(last.axis, last.layerIndex, -last.angle, true);
        moveCounter--;
        updateUI();
    }

    function startTimer() {
        isTimerStarted = true;
        startTime = Date.now();
        timerInterval = setInterval(() => {
            const d = Date.now() - startTime;
            const m = Math.floor(d / 60000);
            const s = Math.floor((d % 60000) / 1000);
            const ms = Math.floor((d % 1000) / 100);
            document.getElementById('timer').innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}.${ms}`;
        }, 100);
    }

    function updateUI() {
        document.getElementById('move-count').innerText = `步數: ${moveCounter}`;
    }

    function animate() {
        requestAnimationFrame(animate);
        if (controls) controls.update();
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('keydown', handleKeyboard);
        
        // 全域暴露函數
        window.changeOrder = (n) => { if(!isAnimating) { currentOrder = n; resetCube(); } };
        window.scramble = () => scrambleCube();
        window.undo = () => undoMove();
        window.resetCube = () => { moveHistory = []; moveCounter = 0; updateStats(); stopTimer(); createCube(currentOrder); };
        window.toggleWireframe = () => { isWireframe = !isWireframe; cubeGroup.children.forEach(c => c.material.forEach(m => m.wireframe = isWireframe)); };
        window.resetCamera = () => { gsap.to(camera.position, {x: 6, y: 6, z: 10, duration: 1}); camera.lookAt(0,0,0); };
        window.toggleTheme = () => { document.body.classList.toggle('light-mode'); scene.background = new THREE.Color(document.body.classList.contains('light-mode') ? 0xf0f0f0 : 0x111111); };
    }

    function createCube(order) {
        if (cubeGroup) scene.remove(cubeGroup);
        cubeGroup = new THREE.Group();
        
        const offset = (order - 1) / 2;
        const geom = new THREE.BoxGeometry(0.95, 0.95, 0.95);

        for (let x = 0; x < order; x++) {
            for (let y = 0; y < order; y++) {
                for (let z = 0; z < order; z++) {
                    const materials = [
                        new THREE.MeshStandardMaterial({ color: (x === order - 1) ? COLORS.right : COLORS.inside }),
                        new THREE.MeshStandardMaterial({ color: (x === 0) ? COLORS.left : COLORS.inside }),
                        new THREE.MeshStandardMaterial({ color: (y === order - 1) ? COLORS.top : COLORS.inside }),
                        new THREE.MeshStandardMaterial({ color: (y === 0) ? COLORS.bottom : COLORS.inside }),
                        new THREE.MeshStandardMaterial({ color: (z === order - 1) ? COLORS.front : COLORS.inside }),
                        new THREE.MeshStandardMaterial({ color: (z === 0) ? COLORS.back : COLORS.inside })
                    ];

                    const cubie = new THREE.Mesh(geom, materials);
                    cubie.position.set(x - offset, y - offset, z - offset);
                    cubeGroup.add(cubie);
                }
            }
        }
        scene.add(cubeGroup);
    }

    async function rotateLayer(axis, layerIndex, angle, saveHistory = true) {
        if (isAnimating) return;
        isAnimating = true;
        startTimer();

        const pivot = new THREE.Group();
        scene.add(pivot);

        const offset = (currentOrder - 1) / 2;
        const layerCoord = layerIndex - offset;

        const targets = [];
        const children = [...cubeGroup.children];
        children.forEach(c => {
            if (Math.abs(c.position[axis] - layerCoord) < 0.1) {
                targets.push(c);
                pivot.attach(c);
            }
        });

        await gsap.to(pivot.rotation, { [axis]: angle, duration: 0.3, ease: "power2.inOut" });

        targets.forEach(c => {
            cubeGroup.attach(c);
            c.position.x = Math.round(c.position.x * 2) / 2;
            c.position.y = Math.round(c.position.y * 2) / 2;
            c.position.z = Math.round(c.position.z * 2) / 2;
        });

        scene.remove(pivot);
        if (saveHistory) {
            moveHistory.push({ axis, layerIndex, angle });
            moveCounter++;
            updateStats();
        }
        isAnimating = false;
    }

    function handleKeyboard(e) {
        const key = e.key.toUpperCase();
        const map = { 
            'U': ['y', currentOrder-1, -Math.PI/2], 
            'D': ['y', 0, Math.PI/2],
            'L': ['x', 0, Math.PI/2], 
            'R': ['x', currentOrder-1, -Math.PI/2],
            'F': ['z', currentOrder-1, -Math.PI/2], 
            'B': ['z', 0, Math.PI/2]
        };
        if (map[key]) rotateLayer(...map[key]);
    }

    async function scrambleCube() {
        if (isAnimating) return;
        resetCube();
        const axes = ['x', 'y', 'z'];
        for (let i = 0; i < 15; i++) {
            const axis = axes[Math.floor(Math.random() * 3)];
            const layer = Math.floor(Math.random() * currentOrder);
            const angle = Math.random() > 0.5 ? Math.PI/2 : -Math.PI/2;
            await rotateLayer(axis, layer, angle, true);
        }
    }

    function undoMove() {
        if (moveHistory.length === 0 || isAnimating) return;
        const last = moveHistory.pop();
        rotateLayer(last.axis, last.layerIndex, -last.angle, false);
        moveCounter--;
        updateStats();
    }

    function updateStats() {
        document.getElementById('move-count').innerText = `步數: ${moveCounter}`;
    }

    function startTimer() {
        if (isTimerRunning) return;
        isTimerRunning = true;
        startTime = Date.now();
        timerInterval = setInterval(() => {
            const diff = Date.now() - startTime;
            const m = Math.floor(diff / 60000);
            const s = Math.floor((diff % 60000) / 1000);
            const ms = Math.floor((diff % 1000) / 100);
            document.getElementById('timer').innerText = 
                `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}.${ms}`;
        }, 100);
    }

    function stopTimer() {
        isTimerRunning = false;
        clearInterval(timerInterval);
        document.getElementById('timer').innerText = "00:00.0";
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        if (controls) controls.update();
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
