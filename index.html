<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ultimate Rubik's Lab - Pro Edition</title>
    <style>
        :root { --primary: #00d2ff; --accent: #3a7bd5; --bg: #0f172a; --panel: rgba(15, 23, 42, 0.9); }
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%); color: #f8fafc; font-family: 'Inter', system-ui, sans-serif; }
        canvas { display: block; touch-action: none; }

        /* UI Overlay */
        #app-ui { position: absolute; inset: 0; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; }
        .panel { pointer-events: auto; background: var(--panel); backdrop-filter: blur(12px); border: 1px solid rgba(255,255,255,0.1); border-radius: 16px; padding: 16px; box-shadow: 0 10px 25px -5px rgba(0,0,0,0.3); }
        
        /* Sidebar */
        .sidebar { width: 220px; display: flex; flex-direction: column; gap: 12px; }
        .stats-box { position: absolute; top: 20px; right: 20px; min-width: 120px; text-align: right; }
        
        .timer { font-size: 28px; font-weight: 800; font-family: 'Courier New', monospace; color: var(--primary); text-shadow: 0 0 10px rgba(0,210,255,0.3); }
        
        .control-group { display: flex; flex-direction: column; gap: 6px; }
        label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #94a3b8; font-weight: 600; }
        
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
        button { background: #334155; border: none; color: white; padding: 8px; border-radius: 8px; cursor: pointer; font-size: 12px; transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); }
        button:hover { background: #475569; transform: translateY(-1px); }
        button:active { transform: translateY(0); }
        button.active { background: linear-gradient(135deg, var(--primary), var(--accent)); box-shadow: 0 4px 12px rgba(58,123,213,0.4); }
        
        .slider-wrap { display: flex; align-items: center; gap: 10px; }
        input[type="range"] { flex: 1; accent-color: var(--primary); }

        .scramble-btn { background: linear-gradient(135deg, #f59e0b, #d97706); font-weight: bold; margin-top: 10px; }

        /* Mobile Optimization */
        @media (max-width: 600px) {
            .sidebar { width: 160px; padding: 10px; }
            .timer { font-size: 20px; }
        }
    </style>
</head>
<body>

<div id="app-ui">
    <div class="sidebar panel">
        <label>Cube Order (階數)</label>
        <div class="grid-3">
            <button class="order-btn" data-val="2">2x2</button>
            <button class="order-btn active" data-val="3">3x3</button>
            <button class="order-btn" data-val="4">4x4</button>
            <button class="order-btn" data-val="5">5x5</button>
            <button class="order-btn" data-val="6">6x6</button>
            <button class="order-btn" data-val="7">7x7</button>
        </div>

        <label>Simulation</label>
        <button class="scramble-btn" id="scramble">SCRAMBLE (打亂)</button>
        <button id="undo">UNDO (悔步)</button>
        
        <label>Visuals</label>
        <div class="slider-wrap">
            <input type="range" id="speed" min="0.1" max="1.0" step="0.1" value="0.4">
        </div>
        <button id="explode">EXPLOSION VIEW (爆炸模式)</button>
        <button id="screenshot">SNAPSHOT (截圖)</button>
        <button id="reset-cam">RESET CAMERA (視角重置)</button>
    </div>

    <div class="stats-box panel">
        <div class="timer" id="timer">00:00.0</div>
        <div style="font-size: 12px; color: #94a3b8; margin-top: 4px;">MOVES: <span id="move-count">0</span></div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.2/index.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import gsap from 'gsap';

    // --- Configuration ---
    let scene, camera, renderer, controls, cubeGroup;
    let order = 3;
    let isAnimating = false;
    let isExploded = false;
    let moveCount = 0;
    let moveHistory = [];
    let startTime, timerInterval;
    let animSpeed = 0.4;

    const COLORS = {
        y: 0xffd500, w: 0xffffff, r: 0xb7121f,
        o: 0xff5800, b: 0x0046ad, g: 0x009b48, inner: 0x050505
    };

    init();
    render();

    function init() {
        scene = new THREE.Scene();
        
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(order * 2, order * 2, order * 3);

        renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lights
        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(10, 20, 15);
        scene.add(sun);

        createCube(order);
        bindEvents();
        loadState();
    }

    // --- Core Cube Logic ---
    function createCube(n) {
        if (cubeGroup) {
            // Memory Cleanup: Dispose geometries and materials
            cubeGroup.children.forEach(c => {
                c.geometry.dispose();
                c.material.forEach(m => m.dispose());
            });
            scene.remove(cubeGroup);
        }

        cubeGroup = new THREE.Group();
        const offset = (n - 1) / 2;
        const geom = new THREE.BoxGeometry(0.97, 0.97, 0.97);

        for (let x = 0; x < n; x++) {
            for (let y = 0; y < n; y++) {
                for (let z = 0; z < n; z++) {
                    // Only render visible cubes or cubes for internal mechanics? 
                    // To keep it simple and robust, we render all, but optimize materials.
                    const mats = [
                        new THREE.MeshStandardMaterial({ color: x === n-1 ? COLORS.g : COLORS.inner, roughness: 0.2, metalness: 0.1 }),
                        new THREE.MeshStandardMaterial({ color: x === 0 ? COLORS.b : COLORS.inner, roughness: 0.2, metalness: 0.1 }),
                        new THREE.MeshStandardMaterial({ color: y === n-1 ? COLORS.y : COLORS.inner, roughness: 0.2, metalness: 0.1 }),
                        new THREE.MeshStandardMaterial({ color: y === 0 ? COLORS.w : COLORS.inner, roughness: 0.2, metalness: 0.1 }),
                        new THREE.MeshStandardMaterial({ color: z === n-1 ? COLORS.r : COLORS.inner, roughness: 0.2, metalness: 0.1 }),
                        new THREE.MeshStandardMaterial({ color: z === 0 ? COLORS.o : COLORS.inner, roughness: 0.2, metalness: 0.1 })
                    ];

                    const cubie = new THREE.Mesh(geom, mats);
                    cubie.position.set(x - offset, y - offset, z - offset);
                    cubeGroup.add(cubie);
                }
            }
        }
        scene.add(cubeGroup);
        saveState();
    }

    async function rotateLayer(axis, layerIdx, angle, history = true) {
        if (isAnimating) return;
        isAnimating = true;
        if (moveCount === 0) startTimer();

        const pivot = new THREE.Group();
        scene.add(pivot);

        const offset = (order - 1) / 2;
        const target = layerIdx - offset;

        const cubies = [];
        const children = [...cubeGroup.children];
        
        children.forEach(c => {
            // Using small epsilon for float comparison to fix "stuck" bug
            if (Math.abs(c.position[axis] - target) < 0.1) {
                cubies.push(c);
                pivot.attach(c);
            }
        });

        await gsap.to(pivot.rotation, {
            [axis]: angle,
            duration: animSpeed,
            ease: "power2.inOut"
        });

        cubies.forEach(c => {
            cubeGroup.attach(c);
            // Self-Correction Logic to prevent drift
            c.position.x = Math.round(c.position.x * 2) / 2;
            c.position.y = Math.round(c.position.y * 2) / 2;
            c.position.z = Math.round(c.position.z * 2) / 2;
            c.rotation.set(
                Math.round(c.rotation.x / (Math.PI/2)) * (Math.PI/2),
                Math.round(c.rotation.y / (Math.PI/2)) * (Math.PI/2),
                Math.round(c.rotation.z / (Math.PI/2)) * (Math.PI/2)
            );
        });

        scene.remove(pivot);
        if (history) {
            moveHistory.push({ axis, layerIdx, angle });
            moveCount++;
            document.getElementById('move-count').innerText = moveCount;
            saveState();
        }
        isAnimating = false;
    }

    // --- Utilities ---
    function bindEvents() {
        document.querySelectorAll('.order-btn').forEach(btn => {
            btn.onclick = () => {
                if (isAnimating) return;
                order = parseInt(btn.dataset.val);
                document.querySelectorAll('.order-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                resetGame();
            };
        });

        document.getElementById('scramble').onclick = async () => {
            if (isAnimating) return;
            for (let i = 0; i < order * 5; i++) {
                const axes = ['x', 'y', 'z'];
                const a = axes[Math.floor(Math.random()*3)];
                const l = Math.floor(Math.random()*order);
                const ang = Math.random() > 0.5 ? Math.PI/2 : -Math.PI/2;
                await rotateLayer(a, l, ang);
            }
        };

        document.getElementById('undo').onclick = () => {
            if (moveHistory.length === 0 || isAnimating) return;
            const m = moveHistory.pop();
            rotateLayer(m.axis, m.layerIdx, -m.angle, false);
            moveCount--;
            document.getElementById('move-count').innerText = moveCount;
        };

        document.getElementById('explode').onclick = () => {
            isExploded = !isExploded;
            cubeGroup.children.forEach(c => {
                const target = c.position.clone().multiplyScalar(isExploded ? 1.5 : 0.666);
                gsap.to(c.position, { x: target.x, y: target.y, z: target.z, duration: 0.5 });
            });
        };

        document.getElementById('screenshot').onclick = () => {
            const data = renderer.domElement.toDataURL("image/png");
            const link = document.createElement('a');
            link.download = 'my-cube.png';
            link.href = data;
            link.click();
        };

        document.getElementById('speed').oninput = (e) => animSpeed = 1.1 - e.target.value;

        document.getElementById('reset-cam').onclick = () => {
            gsap.to(camera.position, { x: order*2, y: order*2, z: order*3, duration: 1 });
        };

        window.addEventListener('keydown', (e) => {
            const key = e.key.toUpperCase();
            const last = order - 1;
            const map = {
                'U': ['y', last, -Math.PI/2], 'D': ['y', 0, Math.PI/2],
                'L': ['x', 0, Math.PI/2], 'R': ['x', last, -Math.PI/2],
                'F': ['z', last, -Math.PI/2], 'B': ['z', 0, Math.PI/2]
            };
            if (map[key]) rotateLayer(...map[key]);
        });

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    }

    function resetGame() {
        moveCount = 0;
        moveHistory = [];
        document.getElementById('move-count').innerText = 0;
        stopTimer();
        createCube(order);
    }

    function startTimer() {
        startTime = Date.now();
        timerInterval = setInterval(() => {
            const diff = Date.now() - startTime;
            const m = Math.floor(diff / 60000);
            const s = Math.floor((diff % 60000) / 1000);
            const ms = Math.floor((diff % 1000) / 100);
            document.getElementById('timer').innerText = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}.${ms}`;
        }, 100);
    }

    function stopTimer() {
        clearInterval(timerInterval);
        document.getElementById('timer').innerText = "00:00.0";
    }

    function saveState() {
        const state = { order, moveCount };
        localStorage.setItem('cube_state', JSON.stringify(state));
    }

    function loadState() {
        const saved = localStorage.getItem('cube_state');
        if (saved) {
            const { order: savedOrder } = JSON.parse(saved);
            // order = savedOrder; // 可以選擇是否自動恢復階數
        }
    }

    function render() {
        requestAnimationFrame(render);
        controls.update();
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
