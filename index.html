<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 終極魔術方塊模擬器</title>
    <style>
        :root { --primary: #3498db; --bg: #111; --text: #eee; }
        body.light-mode { --bg: #f0f0f0; --text: #222; }
        body { margin: 0; overflow: hidden; background-color: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; transition: background 0.3s; }
        canvas { display: block; }

        /* UI Panel */
        #ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 20px; box-sizing: border-box; display: flex; flex-direction: column; justify-content: space-between; }
        .panel { pointer-events: auto; background: rgba(0,0,0,0.7); backdrop-filter: blur(10px); padding: 15px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); }
        .light-mode .panel { background: rgba(255,255,255,0.8); color: #222; border: 1px solid rgba(0,0,0,0.1); }
        
        .stats { position: absolute; top: 20px; right: 20px; text-align: right; }
        .controls { display: flex; flex-direction: column; gap: 10px; width: 220px; }
        .btn-group { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; }
        
        button { background: #444; color: white; border: none; padding: 8px; border-radius: 4px; cursor: pointer; font-size: 12px; transition: 0.2s; }
        button:hover { background: var(--primary); }
        button.active { background: var(--primary); }
        h3 { margin: 0 0 10px 0; font-size: 16px; border-bottom: 1px solid #555; padding-bottom: 5px; }
        .timer { font-size: 24px; font-weight: bold; font-family: monospace; }
    </style>
</head>
<body>

<div id="ui-overlay">
    <div class="controls panel">
        <h3>1. 選擇階數</h3>
        <div class="btn-group">
            <button onclick="changeOrder(2)">2x2</button>
            <button class="active" onclick="changeOrder(3)">3x3</button>
            <button onclick="changeOrder(4)">4x4</button>
        </div>

        <h3>2. 動作控制</h3>
        <button onclick="scramble()">隨機打亂 (Scramble)</button>
        <button onclick="undo()">悔步 (Undo)</button>
        <button onclick="resetCube()">重置方塊 (Reset)</button>

        <h3>3. 視覺與系統</h3>
        <button onclick="toggleWireframe()">透視模式 (Wireframe)</button>
        <button onclick="resetCamera()">視角重置</button>
        <button onclick="toggleTheme()">切換主題 (Dark/Light)</button>
    </div>

    <div class="stats panel">
        <div class="timer" id="timer">00:00.0</div>
        <div id="move-count">步數: 0</div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.2/index.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import gsap from 'gsap';

    let scene, camera, renderer, controls;
    let cubeGroup, currentOrder = 3;
    let isAnimating = false;
    let moveHistory = [];
    let moveCounter = 0;
    let timerInterval, startTime, isTimerRunning = false;
    let isWireframe = false;

    const COLORS = {
        top: 0xffd500, bottom: 0xffffff, front: 0xb7121f,
        back: 0xff5800, left: 0x0046ad, right: 0x009b48, inside: 0x222222
    };

    init();
    animate();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        resetCamera();

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(ambientLight);

        createCube(currentOrder);

        window.addEventListener('resize', onWindowResize);
        window.addEventListener('keydown', handleKeyboard);
        
        // 全域暴露函數
        window.changeOrder = (n) => { if(!isAnimating) { currentOrder = n; resetCube(); } };
        window.scramble = () => scrambleCube();
        window.undo = () => undoMove();
        window.resetCube = () => { moveHistory = []; moveCounter = 0; updateStats(); stopTimer(); createCube(currentOrder); };
        window.toggleWireframe = () => { isWireframe = !isWireframe; cubeGroup.children.forEach(c => c.material.forEach(m => m.wireframe = isWireframe)); };
        window.resetCamera = () => { gsap.to(camera.position, {x: 6, y: 6, z: 10, duration: 1}); camera.lookAt(0,0,0); };
        window.toggleTheme = () => { document.body.classList.toggle('light-mode'); scene.background = new THREE.Color(document.body.classList.contains('light-mode') ? 0xf0f0f0 : 0x111111); };
    }

    function createCube(order) {
        if (cubeGroup) scene.remove(cubeGroup);
        cubeGroup = new THREE.Group();
        
        const offset = (order - 1) / 2;
        const geom = new THREE.BoxGeometry(0.95, 0.95, 0.95);

        for (let x = 0; x < order; x++) {
            for (let y = 0; y < order; y++) {
                for (let z = 0; z < order; z++) {
                    const materials = [
                        new THREE.MeshStandardMaterial({ color: (x === order - 1) ? COLORS.right : COLORS.inside }),
                        new THREE.MeshStandardMaterial({ color: (x === 0) ? COLORS.left : COLORS.inside }),
                        new THREE.MeshStandardMaterial({ color: (y === order - 1) ? COLORS.top : COLORS.inside }),
                        new THREE.MeshStandardMaterial({ color: (y === 0) ? COLORS.bottom : COLORS.inside }),
                        new THREE.MeshStandardMaterial({ color: (z === order - 1) ? COLORS.front : COLORS.inside }),
                        new THREE.MeshStandardMaterial({ color: (z === 0) ? COLORS.back : COLORS.inside })
                    ];

                    const cubie = new THREE.Mesh(geom, materials);
                    cubie.position.set(x - offset, y - offset, z - offset);
                    cubeGroup.add(cubie);
                }
            }
        }
        scene.add(cubeGroup);
    }

    async function rotateLayer(axis, layerIndex, angle, saveHistory = true) {
        if (isAnimating) return;
        isAnimating = true;
        startTimer();

        const pivot = new THREE.Group();
        scene.add(pivot);

        const offset = (currentOrder - 1) / 2;
        const layerCoord = layerIndex - offset;

        const targets = [];
        const children = [...cubeGroup.children];
        children.forEach(c => {
            if (Math.abs(c.position[axis] - layerCoord) < 0.1) {
                targets.push(c);
                pivot.attach(c);
            }
        });

        await gsap.to(pivot.rotation, { [axis]: angle, duration: 0.3, ease: "power2.inOut" });

        targets.forEach(c => {
            cubeGroup.attach(c);
            c.position.x = Math.round(c.position.x * 2) / 2;
            c.position.y = Math.round(c.position.y * 2) / 2;
            c.position.z = Math.round(c.position.z * 2) / 2;
        });

        scene.remove(pivot);
        if (saveHistory) {
            moveHistory.push({ axis, layerIndex, angle });
            moveCounter++;
            updateStats();
        }
        isAnimating = false;
    }

    function handleKeyboard(e) {
        const key = e.key.toUpperCase();
        const map = { 
            'U': ['y', currentOrder-1, -Math.PI/2], 
            'D': ['y', 0, Math.PI/2],
            'L': ['x', 0, Math.PI/2], 
            'R': ['x', currentOrder-1, -Math.PI/2],
            'F': ['z', currentOrder-1, -Math.PI/2], 
            'B': ['z', 0, Math.PI/2]
        };
        if (map[key]) rotateLayer(...map[key]);
    }

    async function scrambleCube() {
        if (isAnimating) return;
        resetCube();
        const axes = ['x', 'y', 'z'];
        for (let i = 0; i < 15; i++) {
            const axis = axes[Math.floor(Math.random() * 3)];
            const layer = Math.floor(Math.random() * currentOrder);
            const angle = Math.random() > 0.5 ? Math.PI/2 : -Math.PI/2;
            await rotateLayer(axis, layer, angle, true);
        }
    }

    function undoMove() {
        if (moveHistory.length === 0 || isAnimating) return;
        const last = moveHistory.pop();
        rotateLayer(last.axis, last.layerIndex, -last.angle, false);
        moveCounter--;
        updateStats();
    }

    function updateStats() {
        document.getElementById('move-count').innerText = `步數: ${moveCounter}`;
    }

    function startTimer() {
        if (isTimerRunning) return;
        isTimerRunning = true;
        startTime = Date.now();
        timerInterval = setInterval(() => {
            const diff = Date.now() - startTime;
            const m = Math.floor(diff / 60000);
            const s = Math.floor((diff % 60000) / 1000);
            const ms = Math.floor((diff % 1000) / 100);
            document.getElementById('timer').innerText = 
                `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}.${ms}`;
        }, 100);
    }

    function stopTimer() {
        isTimerRunning = false;
        clearInterval(timerInterval);
        document.getElementById('timer').innerText = "00:00.0";
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        if (controls) controls.update();
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
