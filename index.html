<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rubik's Geometry Lab - Master Edition</title>
    <style>
        :root { --accent: #00ffcc; --bg: #050505; }
        body { margin: 0; overflow: hidden; background: var(--bg); color: #fff; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        
        #ui { position: absolute; inset: 0; pointer-events: none; display: flex; padding: 20px; gap: 20px; }
        .panel { pointer-events: auto; background: rgba(0,0,0,0.85); border: 1px solid #333; border-radius: 12px; padding: 15px; width: 240px; display: flex; flex-direction: column; gap: 10px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        
        h2 { font-size: 14px; margin: 0; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; }
        .grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 5px; }
        
        button { background: #1a1a1a; border: 1px solid #444; color: #fff; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 11px; transition: 0.2s; }
        button:hover { background: var(--accent); color: #000; border-color: var(--accent); }
        button.active { background: var(--accent); color: #000; }
        
        .timer-box { position: absolute; top: 20px; right: 20px; text-align: right; }
        .timer { font-size: 32px; font-family: monospace; color: var(--accent); }
    </style>
</head>
<body>

<div id="ui">
    <div class="panel">
        <h2>幾何類型 (Type)</h2>
        <div class="grid">
            <button class="type-btn active" data-type="classic">經典 N×N</button>
            <button class="type-btn" data-type="mirror">鏡面異形</button>
            <button class="type-btn" data-type="void">空心方塊</button>
            <button class="type-btn" data-type="pyraminx">金字塔 (WIP)</button>
        </div>

        <h2>階數 (Order)</h2>
        <div class="grid">
            <button class="order-btn" data-val="2">2×2</button>
            <button class="order-btn active" data-val="3">3×3</button>
            <button class="order-btn" data-val="4">4×4</button>
            <button class="order-btn" data-val="5">5×5</button>
        </div>

        <h2>渲染外觀 (Skin)</h2>
        <div class="grid">
            <button class="skin-btn active" data-skin="neon">霓虹電馭</button>
            <button class="skin-btn" data-skin="glass">鋼化玻璃</button>
            <button class="skin-btn" data-skin="metal">黑金工業</button>
        </div>

        <h2>動作 (Actions)</h2>
        <button id="scramble" style="background: #e67e22;">自動打亂</button>
        <button id="solve">智慧還原 (Rewind)</button>
        <button id="reset">重置所有</button>
    </div>

    <div class="timer-box">
        <div class="timer" id="timer">00:00.00</div>
        <div id="status">STATUS: STANDBY</div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.2/index.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import gsap from 'gsap';

    let scene, camera, renderer, controls, cubeGroup;
    let order = 3, currentType = 'classic', currentSkin = 'neon';
    let isAnimating = false, moveHistory = [];
    let startTime, timerInt;

    const COLORS = { 
        y: 0xffff00, w: 0xffffff, r: 0xff0000, 
        o: 0xffa500, b: 0x0000ff, g: 0x00ff00, inner: 0x0a0a0a 
    };

    init();
    render();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);

        camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(order*2, order*2, order*3);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Lights
        const amb = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(amb);
        const point = new THREE.PointLight(0xffffff, 2);
        point.position.set(10, 10, 10);
        scene.add(point);

        createPuzzle();
        bindUI();
    }

    function createPuzzle() {
        if (cubeGroup) {
            cubeGroup.children.forEach(c => { c.geometry.dispose(); c.material.forEach(m => m.dispose()); });
            scene.remove(cubeGroup);
        }
        cubeGroup = new THREE.Group();
        const off = (order - 1) / 2;

        for (let x=0; x<order; x++) {
            for (let y=0; y<order; y++) {
                for (let z=0; z<order; z++) {
                    // 空心邏輯
                    if (currentType === 'void' && 
                        (x>0 && x<order-1) && (y>0 && y<order-1) ||
                        (x>0 && x<order-1) && (z>0 && z<order-1) ||
                        (y>0 && y<order-1) && (z>0 && z<order-1)) continue;

                    let geom;
                    if (currentType === 'mirror') {
                        // 鏡面異形：每個塊大小不同
                        geom = new THREE.BoxGeometry(0.5 + x*0.3, 0.5 + y*0.3, 0.5 + z*0.3);
                    } else {
                        geom = new THREE.BoxGeometry(0.95, 0.95, 0.95);
                    }

                    const mats = createMaterials(x, y, z);
                    const cubie = new THREE.Mesh(geom, mats);
                    cubie.position.set(x-off, y-off, z-off);
                    cubeGroup.add(cubie);
                }
            }
        }
        scene.add(cubeGroup);
    }

    function createMaterials(x, y, z) {
        const getCol = (isEdge, col) => {
            if (!isEdge) return COLORS.inner;
            if (currentSkin === 'glass') return 0x88ccff;
            return col;
        };

        const config = {
            roughness: currentSkin === 'metal' ? 0.1 : 0.4,
            metalness: currentSkin === 'metal' ? 0.9 : 0.1,
            transparent: currentSkin === 'glass',
            opacity: currentSkin === 'glass' ? 0.6 : 1.0,
            emissiveIntensity: currentSkin === 'neon' ? 0.5 : 0
        };

        return [
            new THREE.MeshStandardMaterial({ color: getCol(x===order-1, COLORS.g), ...config }),
            new THREE.MeshStandardMaterial({ color: getCol(x===0, COLORS.b), ...config }),
            new THREE.MeshStandardMaterial({ color: getCol(y===order-1, COLORS.y), ...config }),
            new THREE.MeshStandardMaterial({ color: getCol(y===0, COLORS.w), ...config }),
            new THREE.MeshStandardMaterial({ color: getCol(z===order-1, COLORS.r), ...config }),
            new THREE.MeshStandardMaterial({ color: getCol(z===0, COLORS.o), ...config })
        ];
    }

    async function rotate(axis, idx, ang, record = true) {
        if (isAnimating) return;
        isAnimating = true;
        const pivot = new THREE.Group();
        scene.add(pivot);

        const targetCoord = idx - (order - 1) / 2;
        const targets = [];
        [...cubeGroup.children].forEach(c => {
            if (Math.abs(c.position[axis] - targetCoord) < 0.1) {
                targets.push(c);
                pivot.attach(c);
            }
        });

        await gsap.to(pivot.rotation, { [axis]: ang, duration: 0.3, ease: "power3.inOut" });

        targets.forEach(c => {
            cubeGroup.attach(c);
            c.position.set(Math.round(c.position.x*10)/10, Math.round(c.position.y*10)/10, Math.round(c.position.z*10)/10);
            c.rotation.set(Math.round(c.rotation.x/(Math.PI/2))*Math.PI/2, Math.round(c.rotation.y/(Math.PI/2))*Math.PI/2, Math.round(c.rotation.z/(Math.PI/2))*Math.PI/2);
        });
        scene.remove(pivot);
        if (record) moveHistory.push({ axis, idx, ang });
        isAnimating = false;
    }

    function bindUI() {
        document.querySelectorAll('.order-btn').forEach(b => b.onclick = () => { order = parseInt(b.dataset.val); createPuzzle(); });
        document.querySelectorAll('.type-btn').forEach(b => b.onclick = () => { currentType = b.dataset.type; createPuzzle(); });
        document.querySelectorAll('.skin-btn').forEach(b => b.onclick = () => { currentSkin = b.dataset.skin; createPuzzle(); });
        
        document.getElementById('scramble').onclick = async () => {
            for(let i=0; i<10; i++) {
                const axes = ['x','y','z'];
                await rotate(axes[Math.floor(Math.random()*3)], Math.floor(Math.random()*order), Math.PI/2);
            }
        };

        document.getElementById('solve').onclick = async () => {
            while(moveHistory.length > 0) {
                const m = moveHistory.pop();
                await rotate(m.axis, m.idx, -m.ang, false);
            }
        };

        window.onkeydown = (e) => {
            const k = e.key.toUpperCase();
            const map = { 'U':['y', order-1, -Math.PI/2], 'D':['y', 0, Math.PI/2], 'R':['x', order-1, -Math.PI/2], 'L':['x', 0, Math.PI/2] };
            if(map[k]) rotate(...map[k]);
        };
    }

    function render() {
        requestAnimationFrame(render);
        controls.update();
        renderer.render(scene, camera);
    }
</script>
</body>
</html>
