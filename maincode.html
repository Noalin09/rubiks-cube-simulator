<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 魔術方塊 Pro - GSAP 動畫與互動版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }

        /* UI 介面樣式 */
        #ui-panel {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            color: white;
        }
        .button-group { display: flex; gap: 8px; }
        button {
            padding: 10px 15px;
            cursor: pointer;
            background: #444;
            color: white;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            transition: all 0.2s;
        }
        button:hover { background: #666; }
        button:active { transform: scale(0.9); }
        button.scramble { background: #e67e22; width: 100%; }
        button.scramble:hover { background: #d35400; }
        
        .hint {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255,255,255,0.5);
            font-size: 14px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div class="hint">滑鼠左鍵：旋轉視角 | 右鍵：平移 | 滾輪：縮放</div>

    <div id="ui-panel">
        <div class="button-group">
            <button onclick="handleMove('U')">U (頂)</button>
            <button onclick="handleMove('D')">D (底)</button>
            <button onclick="handleMove('L')">L (左)</button>
            <button onclick="handleMove('R')">R (右)</button>
            <button onclick="handleMove('F')">F (前)</button>
            <button onclick="handleMove('B')">B (後)</button>
        </div>
        <button class="scramble" onclick="scrambleCube()">打亂方塊 (Scramble)</button>
    </div>

    <!-- 載入必要庫 -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.2/index.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import gsap from 'gsap';

        let scene, camera, renderer, controls, rubiksCubeGroup;
        let isAnimating = false;

        const COLORS = {
            top: 0xffd500, bottom: 0xffffff, front: 0xb7121f,
            back: 0xff5800, left: 0x0046ad, right: 0x009b48, inside: 0x111111
        };

        init();
        animate();

        function init() {
            // 1. 場景設定
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            // 2. 相機與控制
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(6, 6, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // 讓旋轉有慣性，手感更好

            // 3. 光照
            const ambientLight = new THREE.AmbientLight(0xffffff, 1);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            // 4. 建立 3x3x3 魔術方塊
            rubiksCubeGroup = new THREE.Group();
            const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);

            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const materials = [
                            new THREE.MeshStandardMaterial({ color: (x === 1) ? COLORS.right : COLORS.inside }),
                            new THREE.MeshStandardMaterial({ color: (x === -1) ? COLORS.left : COLORS.inside }),
                            new THREE.MeshStandardMaterial({ color: (y === 1) ? COLORS.top : COLORS.inside }),
                            new THREE.MeshStandardMaterial({ color: (y === -1) ? COLORS.bottom : COLORS.inside }),
                            new THREE.MeshStandardMaterial({ color: (z === 1) ? COLORS.front : COLORS.inside }),
                            new THREE.MeshStandardMaterial({ color: (z === -1) ? COLORS.back : COLORS.inside })
                        ];
                        const cubie = new THREE.Mesh(geometry, materials);
                        cubie.position.set(x, y, z);
                        rubiksCubeGroup.add(cubie);
                    }
                }
            }
            scene.add(rubiksCubeGroup);

            window.addEventListener('resize', onWindowResize);
            
            // 將控制函數暴露給全域按鈕使用
            window.handleMove = (type) => rotateLayerByMove(type);
            window.scrambleCube = scrambleCube;
        }

        /**
         * 定義每一種轉動對應的軸與座標層
         */
        const MOVE_MAP = {
            'U': { axis: 'y', val: 1, angle: -Math.PI/2 },
            'D': { axis: 'y', val: -1, angle: Math.PI/2 },
            'L': { axis: 'x', val: -1, angle: Math.PI/2 },
            'R': { axis: 'x', val: 1, angle: -Math.PI/2 },
            'F': { axis: 'z', val: 1, angle: -Math.PI/2 },
            'B': { axis: 'z', val: -1, angle: Math.PI/2 }
        };

        function rotateLayerByMove(type) {
            if (isAnimating) return;
            const move = MOVE_MAP[type];
            executeRotation(move.axis, move.val, move.angle);
        }

        async function executeRotation(axis, layerValue, angle) {
            isAnimating = true;
            const pivot = new THREE.Group();
            scene.add(pivot);

            const activeCubies = [];
            const children = [...rubiksCubeGroup.children];

            children.forEach(cubie => {
                if (Math.round(cubie.position[axis]) === layerValue) {
                    activeCubies.push(cubie);
                    pivot.attach(cubie);
                }
            });

            // 使用 GSAP 進行平滑動畫
            await gsap.to(pivot.rotation, {
                [axis]: angle,
                duration: 0.4,
                ease: "power2.inOut"
            });

            // 結束後的清理工作
            activeCubies.forEach(cubie => {
                rubiksCubeGroup.attach(cubie);
                cubie.position.x = Math.round(cubie.position.x);
                cubie.position.y = Math.round(cubie.position.y);
                cubie.position.z = Math.round(cubie.position.z);
            });
            scene.remove(pivot);
            isAnimating = false;
        }

        async function scrambleCube() {
            if (isAnimating) return;
            const moves = Object.keys(MOVE_MAP);
            for (let i = 0; i < 20; i++) {
                const randomMove = moves[Math.floor(Math.random() * moves.length)];
                const move = MOVE_MAP[randomMove];
                // 打亂時動畫加快
                await executeRotation(move.axis, move.val, move.angle);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // 必須更新才能實現阻尼效果
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
